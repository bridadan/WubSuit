#ifndef __MIDI_H_
#define __MIDI_H_ 1

#define MIDI_DEFAULT_CHANNEL 0
#define MIDI_DEFAULT_VELOCITY 127

void MIDI_sendMessage(uint8_t[] dataBytes, int numberOfDataBytes) {
    int i;
    for (i = 0; i < numberOfDataBytes; i++) {
    	// Replace with appropriate UART Driver function
        UART_SendByte(dataBytes[i]);
    }
}

void MIDI_noteOn(uint8_t note, uint8_t velocity = MIDI_DEFAULT_VELOCITY, uint8_t channel = MIDI_DEFAULT_CHANNEL) {
    uint8_t data[3] = { 0x90 | (channel & 0xF), note, velocity};
    MIDI_sendMessage(data, 3);
}

void MIDI_noteOff(uint8_t note, uint8_t velocity = MIDI_DEFAULT_VELOCITY, uint8_t channel = MIDI_DEFAULT_CHANNEL) {
    uint8_t data[3] = { 0x80 | (channel & 0xF), note, velocity};
    MIDI_sendMessage(data, 3);
}

void MIDI_pitchWheelChange(unit16_t value, uint8_t channel = MIDI_DEFAULT_CHANNEL) {
	unit8_t data[3] = {0xE0 | (channel & 0xF), value & 0x7F, value & 0x3F80>> 8};
	MIDI_sendMessage(data, 3);
}

void MIDI_controlChange(uint8_t control, uint8_t value, uint8_t channel = MIDI_DEFAULT_CHANNEL) {
    uint8_t data[3] = { 0x80 | (channel & 0xF), control, value};
    MIDI_sendMessage(data, 3);
}

void MIDI_programChange(uint8_t program, uint8_t channel = MIDI_DEFAULT_CHANNEL) {
    uint8_t data[2] = { 0x80 | (channel & 0xF), program};
    MIDI_sendMessage(data, 2);
}

// Commands not implemented: Aftertouch and Channel Pressure

#endif /* __MIDI_H_ */
